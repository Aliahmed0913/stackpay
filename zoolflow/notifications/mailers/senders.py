import logging
from django.db import transaction as db_transaction
from django.template.loader import render_to_string
from .providers import MailGunProvider
from ..models import EmailEvent
from ..services.trackers import UpdateEmailEventTracker
from users.models import VerificationCode
from transactions.models import Transaction

logger = logging.getLogger(__name__)


def mail_verify_code(user_code: VerificationCode):
    """
    Create and configure EmailMessage instance then send the object
    """
    subject = "Verify your email"
    send_to = user_code.user.email
    verification_code = user_code.code
    # email_from = DEFAULT_FROM_EMAIL
    email_body = render_to_string(
        "notifications/templates/verification_code.html",
        {"user": user_code.user, "code": verification_code},
    )
    _send_idempotent_email(
        email_body,
        subject,
        send_to,
        "Verification code",
        verification_code,
    )


def mail_transaction_state(transaction_id):
    """
    Create and configure EmailMessage instance then send the object
    """
    # Define email arguments (recipient, subject, body)
    txn = Transaction.objects.get(transaction_id=transaction_id)
    state = txn.get_state_display()
    user_email = txn.customer.user.email
    username = txn.customer.user.username
    subject = f"Transaction {transaction_id} Status Update"
    send_to = f"{username} <{user_email}>"
    email_body = f"""
    Hello {username},\n\n
    Your transaction with ID {transaction_id} state is {state}.\n\n
    Thank you for using our service.
    """
    _send_idempotent_email(
        email_body,
        subject,
        send_to,
        "Transaction state",
        transaction_id,
    )


def _send_idempotent_email(email_body, subject, send_to, purpose, key=None):
    """
    First check if there exsiting email-event with the same key.

    Representing the idempotent_key based on purpose:
        - Transaction info we use transaction id generated by provider.
        - Code info we use the code itself as a key.
    """
    # initialize email event for idempotency and tracking status
    with db_transaction.atomic():
        event, created = EmailEvent.objects.get_or_create(
            idempotent_key=key,
            to_email=send_to,
            purpose=purpose,
        )
        if not created:
            logger.warning(
                f"""
                Email for {purpose} with key {key}
                           already Processed.
                           """
            )
            return

        def _forward_email():
            # Use MailGunProvider to send the email
            mail_provider = MailGunProvider()
            reponse_message = mail_provider.send_email(
                recipient=send_to, email_subject=subject, email_body=email_body
            )
            # update email event status based on provider response
            if "Queued." in reponse_message["message"]:
                response_message = reponse_message["id"]
                UpdateEmailEventTracker.when_queued(event, response_message)

        db_transaction.on_commit(_forward_email)
